{
  "mnemonic": "IDIV",
  "summary": "Signed Divide",
  "index": 231,
  "instructions": [
    {
      "opcode": "F6 /7",
      "instr": "IDIV r/m8",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "Signed divide AX by r/m8, with result stored in: AL := Quotient, AH := Remainder."
    },
    {
      "opcode": "REX + F6 /7",
      "instr": "IDIV r/m8*",
      "op_en": "M",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "Signed divide AX by r/m8, with result stored in AL := Quotient, AH := Remainder."
    },
    {
      "opcode": "F7 /7",
      "instr": "IDIV r/m16",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "Signed divide DX:AX by r/m16, with result stored in AX := Quotient, DX := Remainder."
    },
    {
      "opcode": "F7 /7",
      "instr": "IDIV r/m32",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "Signed divide EDX:EAX by r/m32, with result stored in EAX := Quotient, EDX := Remainder."
    },
    {
      "opcode": "REX.W + F7 /7",
      "instr": "IDIV r/m64",
      "op_en": "M",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "Signed divide RDX:RAX by r/m64, with result stored in RAX := Quotient, RDX := Remainder."
    }
  ],
  "op_en": [
    {
      "op_en": "M",
      "tuple_type": "ModRM:r/m (r)",
      "operand_1": "NA",
      "operand_2": "NA",
      "operand_3": "NA"
    }
  ],
  "page_desc": [
    "Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor).",
    "Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.",
    "In 64-bit mode, the instruction\u2019s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the signed value in RDX:RAX by the source operand. RAX contains a 64-bit quotient; RDX contains a 64-bit remainder.",
    "See the summary chart at the beginning of this section for encoding data and limits. SeeTable 3-51."
  ]
}
