{
  "mnemonic": "LEA",
  "summary": "Load Effective Address",
  "index": 310,
  "instructions": [
    {
      "opcode": "8D /r",
      "instr": "LEA r16,m",
      "op_en": "RM",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "Store effective address for m in register r16."
    },
    {
      "opcode": "8D /r",
      "instr": "LEA r32,m",
      "op_en": "RM",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "Store effective address for m in register r32."
    },
    {
      "opcode": "REX.W + 8D /r",
      "instr": "LEA r64,m",
      "op_en": "RM",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "Store effective address for m in register r64."
    }
  ],
  "op_en": [
    {
      "op_en": "RM",
      "tuple_type": "ModRM:reg (w)",
      "operand_1": "ModRM:r/m (r)",
      "operand_2": "NA",
      "operand_3": "NA"
    }
  ],
  "page_desc": [
    "Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment.",
    "Different assemblers may use different algorithms based on the size attribute and symbolic reference of the source operand.",
    "In 64-bit mode, the instruction\u2019s destination operand is governed by operand size attribute, the default operand size is 32 bits. Address calculation is governed by address size attribute, the default address size is 64-bits. In 64-bit mode, address size of 16 bits is not encodable. SeeTable 3-55."
  ]
}
