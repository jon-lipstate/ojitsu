{
  "mnemonic": "IMUL",
  "summary": "Signed Multiply",
  "index": 232,
  "instructions": [
    {
      "opcode": "F6 /5",
      "instr": "IMUL r/m8*",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "AX:= AL \u2217 r/m byte."
    },
    {
      "opcode": "F7 /5",
      "instr": "IMUL r/m16",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "DX:AX := AX \u2217 r/m word."
    },
    {
      "opcode": "F7 /5",
      "instr": "IMUL r/m32",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "EDX:EAX := EAX \u2217 r/m32."
    },
    {
      "opcode": "REX.W + F7 /5",
      "instr": "IMUL r/m64",
      "op_en": "M",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "RDX:RAX := RAX \u2217 r/m64."
    },
    {
      "opcode": "0F AF /r",
      "instr": "IMUL r16, r/m16",
      "op_en": "RM",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "word register := word register \u2217 r/m16."
    },
    {
      "opcode": "0F AF /r",
      "instr": "IMUL r32, r/m32",
      "op_en": "RM",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "doubleword register := doubleword register \u2217 r/m32."
    },
    {
      "opcode": "REX.W + 0F AF /r",
      "instr": "IMUL r64, r/m64",
      "op_en": "RM",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "Quadword register := Quadword register \u2217 r/m64."
    },
    {
      "opcode": "6B /r ib",
      "instr": "IMUL r16, r/m16, imm8",
      "op_en": "RMI",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "word register := r/m16 \u2217 sign-extended immediate byte."
    },
    {
      "opcode": "6B /r ib",
      "instr": "IMUL r32, r/m32, imm8",
      "op_en": "RMI",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "doubleword register := r/m32 \u2217 sign-extended immediate byte."
    },
    {
      "opcode": "REX.W + 6B /r ib",
      "instr": "IMUL r64, r/m64, imm8",
      "op_en": "RMI",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "Quadword register := r/m64 \u2217 sign-extended immediate byte."
    },
    {
      "opcode": "69 /r iw",
      "instr": "IMUL r16, r/m16, imm16",
      "op_en": "RMI",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "word register := r/m16 \u2217 immediate word."
    },
    {
      "opcode": "69 /r id",
      "instr": "IMUL r32, r/m32, imm32",
      "op_en": "RMI",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "doubleword register := r/m32 \u2217 immediate doubleword."
    },
    {
      "opcode": "REX.W + 69 /r id",
      "instr": "IMUL r64, r/m64, imm32",
      "op_en": "RMI",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "Quadword register := r/m64 \u2217 immediate doubleword."
    },
    {
      "opcode": "NOTES: * In64-bitmode,r/m8cannotbeencodedtoaccessthefollowingbyteregistersifaREXprefixisused:AH,BH,CH,DH."
    }
  ],
  "op_en": [
    {
      "op_en": "M",
      "tuple_type": "ModRM:r/m (r, w)",
      "operand_1": "NA",
      "operand_2": "NA",
      "operand_3": "NA"
    },
    {
      "op_en": "RM",
      "tuple_type": "ModRM:reg (r, w)",
      "operand_1": "ModRM:r/m (r)",
      "operand_2": "NA",
      "operand_3": "NA"
    },
    {
      "op_en": "RMI",
      "tuple_type": "ModRM:reg (r, w)",
      "operand_1": "ModRM:r/m (r)",
      "operand_2": "imm8/16/32",
      "operand_3": "NA"
    }
  ],
  "page_desc": [
    "Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.",
    "When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
    "The CF and OF flags are set when the signed integer value of the intermediate product differs from the sign extended operand-size-truncated product, otherwise the CF and OF flags are cleared.",
    "The three forms of the IMUL instruction are similar in that the length of the product is calculated to twice the length of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and three- operand forms, however, the result is truncated to the length of the destination before it is stored in the destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits are lost.",
    "The two- and three-operand forms may also be used with unsigned operands because the lower half of the product is the same regardless if the operands are signed or unsigned. The CF and OF flags, however, cannot be used to determine if the upper half of the result is non-zero.",
    "In 64-bit mode, the instruction\u2019s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. Use of REX.W modifies the three forms of the instruction as follows."
  ]
}
