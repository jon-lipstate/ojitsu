{
  "mnemonic": "DEC",
  "summary": "Decrement by 1",
  "index": 119,
  "instructions": [
    {
      "opcode": "FE /1",
      "instr": "DEC r/m8",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "Decrement r/m8 by 1."
    },
    {
      "opcode": "REX + FE /1",
      "instr": "DEC r/m8*",
      "op_en": "M",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "Decrement r/m8 by 1."
    },
    {
      "opcode": "FF /1",
      "instr": "DEC r/m16",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "Decrement r/m16 by 1."
    },
    {
      "opcode": "FF /1",
      "instr": "DEC r/m32",
      "op_en": "M",
      "x64": "Valid",
      "x32": "Valid",
      "desc": "Decrement r/m32 by 1."
    },
    {
      "opcode": "REX.W + FF /1",
      "instr": "DEC r/m64",
      "op_en": "M",
      "x64": "Valid",
      "x32": "N.E.",
      "desc": "Decrement r/m64 by 1."
    },
    {
      "opcode": "48+rw",
      "instr": "DEC r16",
      "op_en": "O",
      "x64": "N.E.",
      "x32": "Valid",
      "desc": "Decrement r16 by 1."
    },
    {
      "opcode": "48+rd",
      "instr": "DEC r32",
      "op_en": "O",
      "x64": "N.E.",
      "x32": "Valid",
      "desc": "Decrement r32 by 1."
    }
  ],
  "op_en": [
    {
      "op_en": "M",
      "tuple_type": "ModRM:r/m (r, w)",
      "operand_1": "NA",
      "operand_2": "NA",
      "operand_3": "NA"
    },
    {
      "op_en": "O",
      "tuple_type": "opcode + rd (r, w)",
      "operand_1": "NA",
      "operand_2": "NA",
      "operand_3": "NA"
    }
  ],
  "page_desc": [
    "Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)",
    "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
    "In 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes). Otherwise, the instruction\u2019s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.",
    "See the summary chart at the beginning of this section for encoding data and limits."
  ]
}
